use serde::{Deserialize, Serialize};

/// Advice generated by the rule engine or LLM
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Advice {
    pub shop: Vec<ShopAdvice>,
    pub econ: Option<EconAdvice>,
    pub items: Vec<ItemAdvice>,
    pub comp: Option<CompAdvice>,
    pub llm_insight: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShopAdvice {
    pub slot_index: usize,
    pub action: ShopAction,
    pub reason: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ShopAction {
    Buy,
    Skip,
    Consider,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EconAdvice {
    pub action: EconAction,
    pub reason: String,
    pub target_gold: Option<u32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EconAction {
    Level,
    Roll,
    Save,
    SlowRoll,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ItemAdvice {
    pub item1: String,
    pub item2: String,
    pub result: String,
    pub priority: u32,
    pub reason: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompAdvice {
    pub comp_name: String,
    pub match_score: f64,
    pub missing_units: Vec<String>,
    pub core_items: Vec<String>,
}

/// Placeholder for the advisor pipeline.
/// Will be implemented in Phase 4 with rule engine.
pub fn generate_advice(_state: &tft_state::GameState) -> Advice {
    Advice::default()
}
